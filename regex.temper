
let { ... } = import("std/regex");

class Slot {
  public name: String;
  public regex: Regex;
}

let stringToRegex(text: String): Regex {
  return new Sequence(text.split("").map(fn(s: String): Regex {
    return new CodePoints(s);
  }));
}

class Parser {
  public chars: List<String>;
  public pos: Int;
  public slots: ListBuilder<Slot>;
  public errors: ListBuilder<String>;

  public constructor(str: String) {
    chars = str.split("");
    pos = 0;
    slots = new ListBuilder<Slot>();
    errors = new ListBuilder<String>();
  }

  public addString(name: String, text: String): Void {
    slots.add(new Slot(name, stringToRegex(text)));
  }

  public addRegex(name: String, regex: Regex): Void {
    slots.add(new Slot(name, regex));
  }

  public error(e: String): Void {
    errors.add("${e}");
  }

  public isDone(): Boolean {
    return chars.length <= pos;
  }

  public peek(): String {
    if (isDone()) {
      error("done");
      return "";
    }
    return chars[pos];
  }

  public advance(): Void {
    pos += 1;
  }

  public read(): String {
    let ret = peek();
    advance();
    return ret;
  }

  public matchChar(s: String): Boolean {
    if (peek() == s) {
      advance();
      return true;
    } else {
      return false;
    }
  }

  public charClassBody(): Regex {
    let invert = matchChar("^");
    let opts = new ListBuilder<CodePart>();
    while (!matchChar("]")) {
      let firstChar = read();
      if (matchChar("-")) {
        let secondChar = read();
        opts.add(new CodeRange(firstChar.codePoints.read(), secondChar.codePoints.read()));
      } else {
        opts.add(new CodePoints(firstChar));
      }
    }
    return new CodeSet(opts.toList(), invert);
  }

  public readPostfix(exist: Regex): Regex {
    if (matchChar("+")) {
      return new Repeat(exist, 1, null, matchChar("?"));
    } else if (matchChar("*")) {
      return new Repeat(exist, 0, null, matchChar("?"));
    } else if (matchChar("?")) {
      return new Repeat(exist, 0, 1, matchChar("?"));
    } else {
      return exist;
    }
  }

  public readSingle(): Regex | Null {
    if (matchChar("[")) {
      return charClassBody();
    } 
    if (matchChar("(")) {
      if (matchChar("?")) {
        // non capturing group
        if (matchChar(":")) {
          let regex = readOr();
          if (!matchChar(")")) {
            error("closing paren");
            return null;
          }
          return regex;
        } else {
          let str = new ListBuilder<String>();
          while (matchChar(" ")) {}
          while (!matchChar("=")) {
            str.add(read());
            while (matchChar(" ")) {}
          }
          let regex = readOr();
          if (!matchChar(")")) {
            error("closing paren");
            return null;
          }
          let name = str.join("", fn(s: String): String{s});
          match (regex) {
            is Regex -> return new Capture(name, regex);
            else -> return null;
          }
        }
      } else {
        let regex = readOr();
        if (!matchChar(")")) {
          error("closing paren");
          return null;
        }
        return regex;
      }
    } else if (matchChar("^")) {
      return Begin;
    } else if (matchChar("$")) {
      return End;
    } else if (matchChar(".")) {
      return Dot;
    } else if (matchChar("\\")) {
      if (matchChar("b")) {
        return WordBoundary;
      } else if (matchChar("d")) {
        return Digit;
      } else if (matchChar("w")) {
        return Word;
      } else if (matchChar("s")) {
        return Space;
      } else if (matchChar("(")) {
        let parts = new ListBuilder<String>();
        while (!matchChar(")")) {
          if (isDone()) {
            error("missing closing paren in \\(...)");
            return null;
          }
          parts.add(read());
        }
        let str = parts.join("", fn(s: String): String{s});
        for (var i = 0; i < slots.length; i++) {
          let slot = slots[i];
          if (slot.name == str) {
            return slot.regex;
          }
        }
        error("no such slot: ${str}");
        return null;
      } else {
        error("unknown escape code: \\${peek()}");
        return null;
      }
    } else {
      return new CodePoints(read());
    }
  }

  public readSeq(): Regex | Null {
    let seq = new ListBuilder<Regex>();
    while (!isDone() && peek() != "|" && peek() != ")") {
      let regex = readSingle();
      match (regex) {
        is Regex -> seq.add(readPostfix(regex));
        else -> return null;
      }
    }
    return new Sequence(seq.toList());
  }

  public readOr(): Regex | Null {
    let ors = new ListBuilder<Regex>();
    while (!isDone() && peek() != ")") {
      if (ors.length != 0 && !matchChar("|")) {
        console.log(pos.toString());
        error("or");
        return null;
      }
      let regex = readSeq();
      match (regex) {
        is Regex -> ors.add(regex);
        else -> return null;
      }
    }
    return new Or(ors.toList());
  }
}

export let compileWith(src: String, keys: List<String>, values: List<Regex | Null>): CompiledRegex | Null {
  let parser = new Parser(src);
  for (var i = 0; i < keys.length && i < values.length; i++) {
    let val = values[i];
    match (val) {
      is Regex -> parser.addRegex(keys[i], val);
    }
  }
  let regex = parser.readOr();
  match (regex) {
    is Regex -> new Capture("full", regex).compiled();
    else -> null;
  }
}

export let compile(src: String): CompiledRegex | Null {
  let parser = new Parser(src);
  let regex = parser.readOr();
  match (regex) {
    is Regex -> new Capture("full", regex).compiled();
    else -> null;
  }
}

export let subWith(src: String, keys: List<String>, values: List<Regex | Null>): Regex | Null {
  let parser = new Parser(src);
  for (var i = 0; i < keys.length && i < values.length; i++) {
    let val = values[i];
    match (val) {
      is Regex -> parser.addRegex(keys[i], val);
    }
  }
  parser.readOr();
}

export let sub(src: String): Regex | Null {
  let parser = new Parser(src);
  parser.readOr();
}
