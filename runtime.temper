
let { ... } = import("std/regex");

let isCodePointWordChar(code: Int): Boolean {
  (48 <= code && code <= 57) // this range is 0 to 9, like above
         || (65 <= code && code <= 90) // this range is A to Z (uppercase)
         || (97 <= code && code <= 122) // this range is a to z (lowercase)
}

class Matcher {
  public str: List<String>;
  public head: Int;
  public groups: MapBuilder<String, Group>;
  public depth: Int;

  constructor(src: String): Void {
    str = src.split("");
    head = 0;
    groups = new MapBuilder<String, Group>();
    depth = 0;
  }

  public advance(): Void {
    // console.log("${head.toString()} next");
    head += 1;
  }

  public setHead(val: Int): Void {
    // console.log("${head.toString()} to ${val.toString()}");
    head = val;
  }

  public matchCapture(regex: Capture): Boolean {
    var begin = head;
    if (matchRegex(regex.item)) {
      var end = head;
      var list = new ListBuilder<String>();
      for (var i = begin; i < end; i++) {
        list.add(str[i]);
      }
      var text = list.join("", fn(s: String): String{s});
      groups[regex.name] = new Group(regex.name, text, begin);
      return true;
    } else {
      setHead(begin);
      return false;
    }
  }

  public matchCodePoints(regex: CodePoints): Boolean {
    if (depth == 0) {
      var split = regex.value.split("");
      for (var i = 0; i < split.length ; i++) {
        if ((str[head+i] orelse "") != split[i]) {
          return false;
        }
      }
      for (var i = 0; i < split.length; i++) {
        advance();
      }
      return true;
    } else {
      var split = regex.value.split("");
      for (var i = 0; i < split.length ; i++) {
        if ((str[head] orelse "") == split[i]) {
          advance();
          return true;
        }
      }
      return false;
    }
  }

  public matchDot(): Boolean {
    return if (head < str.length) {
      advance();
      true
    } else {
      false
    }
  }

  public matchDigit(): Boolean {
    if (head >= str.length) {
      return false;
    }
    var code = str[head].codePoints.read();
    return if (48 <= code && code <= 57) {
      advance();
      true
    } else {
      false
    }
  }

  public matchWord(): Boolean {
    if (isCodePointWordChar(str[head].codePoints.read() orelse 0)) {
      advance();
      return true;
    } else {
      return false;
    }
  }

  public matchWordBoundary(): Boolean {
    return isCodePointWordChar(str[head-1].codePoints.read() orelse 0)
        != isCodePointWordChar(str[head].codePoints.read() orelse 0);
  }

  public matchSpecial(regex: Special): Boolean {
    if (regex == Begin) {
      return head == 0;
    } else if (regex == Dot) { 
      return matchDot();
    } else if (regex == End) {
      return head >= str.length;
    } else if (regex == WordBoundary) { 
      return matchWordBoundary();
    } else if (regex == Digit) {
      return matchDigit();
    } else if(regex == Space) {
      return head < str.length && (
        str[head] == ' '
        || str[head] == '\t'
        || str[head] == '\r'
        || str[head] == '\n'
      );
    } else if (regex == Word) {
      return matchWord();
    } else {
      return false;
    }
  }

  public matchCodeRange(regex: CodeRange): Boolean {
    if (head >= str.length) {
      return false;
    }
    var n = str[head].codePoints.read();
    if (regex.min <= n && n <= regex.max) {
      advance();
      return true;
    } else {
      return false;
    }
  }

  public matchCodeSet(regex: CodeSet): Boolean {
    var begin = head;
    if (regex.negated) {
      for (var i = 0; i < regex.items.length; i++) {
        depth += 1;
        var res = matchRegex(regex.items[i]);
        depth -= 1;
        if (res) {
          return false
        }
        setHead(begin);
      }
      advance();
      return true;
    } else {
      for (var i = 0; i < regex.items.length; i++) {
        depth += 1;
        var res = matchRegex(regex.items[i]);
        depth -= 1;
        if (res) {
          return true;
        }
        setHead(begin);
      }
      return false;
    }
  }

  public matchOr(regex: Or): Boolean {
    var start = head;
    for (var i = 0; i < regex.items.length; i++) {
      if (matchRegex(regex.items[i])) {
        return true;
      }
    }
    setHead(start);
    return false;
  }

  public matchRepeat(regex: Repeat): Boolean {
    var start = head;
    for (var i = 0; i < regex.min; i++) {
      if (!matchRegex(regex.item)) {
        setHead(start);
        return false;
      }
    }
    if (regex.max == null) {
      while (true) {
        var mid = head;
        if (!matchRegex(regex.item)) {
          setHead(mid);
          return true;
        }
      }
    } else {
      for (var i = regex.min; i < regex.max; i++) {
        var mid = head;
        if (!matchRegex(regex.item)) {
          setHead(mid);
          return true;
        }
      }
      return true;
    }
  }

  public matchSequence(regex: Sequence): Boolean {
    var start = head;
    for (var i = 0; i < regex.items.length; i++) {
      if (!matchRegex(regex.items[i])) {
        setHead(start);
        return false;
      }
    }
    return true;
  }

  public matchRegex(regex: Regex): Boolean {
    match (regex) {
      is Capture -> matchCapture(regex);
      is CodePoints -> matchCodePoints(regex);
      is CodeRange -> matchCodeRange(regex);
      is CodeSet -> matchCodeSet(regex);
      is Or -> matchOr(regex);
      is Repeat -> matchRepeat(regex);
      is Sequence -> matchSequence(regex);
      is Special -> matchSpecial(regex);
      else -> false;
    }
  }

  public resetGroups(regex: Regex): Void {
    match (regex) {
      is Capture -> do {
        groups[regex.name] = new Group(regex.name, "", -1);
        resetGroups(regex.item);
      }
      is Repeat -> resetGroups(regex.item);
      is Or -> do {
        for (var i = 0; i < regex.items.length; i++) {
          resetGroups(regex.items[i]);
        }
      }
      is Sequence -> do {
        for (var i = 0; i < regex.items.length; i++) {
          resetGroups(regex.items[i]);
        }
      }
      else -> false;
    }
  }
}

interface TemperRegex {
  public constructor(data: Regex);
  public found(text: String): Boolean;
  public find(text: String): Map<String, Group>;
}

export class TemperCompiledRegex extends TemperRegex {
  public data: Regex;

  public constructor(re: Regex) {
    data = re;
  }

  public found(text: String): Boolean {
    for (var i = 0; i < text.codePoints.length; i++) {
      var m = new Matcher(text);
      m.setHead(i);
      m.resetGroups(data);
      if (m.matchRegex(data)) {
        return true;
      }
    }
    return false;
  }
  
  public find(text: String): Map<String, Group> | NoResult {
    for (var i = 0; i < text.codePoints.length; i++) {
      var m = new Matcher(text);
      m.setHead(i);
      m.resetGroups(data);
      if (m.matchRegex(data)) {
        return m.groups.toMap();
      }
    }
    fail()
  }
}
